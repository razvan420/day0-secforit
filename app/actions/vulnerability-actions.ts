'use server'

import { revalidatePath } from 'next/cache';

interface VulnerabilityStats {
  success: boolean;
  totalVulnerabilities?: number;
  cisaCount?: number;
  nvdCount?: number;
  githubCount?: number;
  exploitedCount?: number;
  criticalCount?: number;
  lastUpdated?: string;
  feedVersion?: string;
  error?: string;
}

interface FeedHealth {
  success: boolean;
  status?: string;
  responseTime?: number;
  dataFreshness?: string;
  sources?: {
    cisa: boolean;
    nvd: boolean;
    github: boolean;
    epss: boolean;
  };
  error?: string;
}

export async function refreshVulnerabilityFeed() {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const startTime = Date.now();
    
    // Force refresh by bypassing cache
    const response = await fetch(`${baseUrl}/rss`, {
      method: 'GET',
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-cache'
      }
    });
    
    const responseTime = Date.now() - startTime;
    
    if (!response.ok) {
      throw new Error(`RSS feed returned status ${response.status}`);
    }
    
    // Revalidate the home page cache
    revalidatePath('/');
    
    return { 
      success: true, 
      status: response.status,
      responseTime,
      vulnerabilities: response.headers.get('X-Total-Vulnerabilities') || '0',
      lastUpdated: response.headers.get('X-Last-Updated') || new Date().toISOString()
    };
  } catch (error) {
    console.error('Error refreshing feed:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to refresh feed' 
    };
  }
}

export async function getVulnerabilityStats(): Promise<VulnerabilityStats> {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const response = await fetch(`${baseUrl}/rss`, {
      cache: 'no-store'
    });
    
    if (!response.ok) {
      throw new Error(`Feed unavailable: ${response.status}`);
    }
    
    const totalVulns = parseInt(response.headers.get('X-Total-Vulnerabilities') || '0');
    const cisaCount = parseInt(response.headers.get('X-CISA-Count') || '0');
    const nvdCount = parseInt(response.headers.get('X-NVD-Count') || '0');
    const githubCount = parseInt(response.headers.get('X-GitHub-Count') || '0');
    const exploitedCount = parseInt(response.headers.get('X-Exploited-Count') || '0');
    const criticalCount = parseInt(response.headers.get('X-Critical-Count') || '0');
    const feedVersion = response.headers.get('X-Feed-Version') || '1.0';
    const lastUpdated = response.headers.get('X-Last-Updated') || new Date().toISOString();
    
    return {
      success: true,
      totalVulnerabilities: totalVulns,
      cisaCount,
      nvdCount,
      githubCount,
      exploitedCount,
      criticalCount,
      feedVersion,
      lastUpdated
    };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to get stats' 
    };
  }
}

export async function checkFeedHealth(): Promise<FeedHealth> {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const startTime = Date.now();
    
    // Use HEAD request for health check
    const response = await fetch(`${baseUrl}/rss`, {
      method: 'HEAD',
      cache: 'no-store'
    });
    
    const responseTime = Date.now() - startTime;
    
    if (!response.ok) {
      throw new Error(`Health check failed: ${response.status}`);
    }
    
    const lastUpdated = response.headers.get('X-Last-Updated');
    const dataAge = lastUpdated ? Date.now() - new Date(lastUpdated).getTime() : 0;
    const dataFreshness = dataAge < 3600000 ? 'fresh' : dataAge < 7200000 ? 'stale' : 'outdated';
    
    return {
      success: true,
      status: 'healthy',
      responseTime,
      dataFreshness,
      sources: {
        cisa: true, // Would implement actual source checks
        nvd: true,
        github: true,
        epss: true
      }
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Health check failed'
    };
  }
}

export async function validateRSSFeed() {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const response = await fetch(`${baseUrl}/rss`);
    
    if (!response.ok) {
      return { success: false, error: 'RSS feed not accessible' };
    }
    
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/rss+xml')) {
      return { success: false, error: 'Invalid RSS content type' };
    }
    
    const content = await response.text();
    
    // Basic RSS validation
    if (!content.includes('<?xml') || !content.includes('<rss')) {
      return { success: false, error: 'Invalid RSS format' };
    }
    
    // Check for required RSS elements
    const requiredElements = ['<channel>', '<title>', '<description>', '<link>'];
    for (const element of requiredElements) {
      if (!content.includes(element)) {
        return { success: false, error: `Missing required RSS element: ${element}` };
      }
    }
    
    const itemCount = (content.match(/<item>/g) || []).length;
    
    return { 
      success: true, 
      message: 'RSS feed is valid',
      size: content.length,
      items: itemCount,
      encoding: 'UTF-8',
      version: content.match(/version="([^"]+)"/)?.[1] || '2.0'
    };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'RSS validation failed' 
    };
  }
}

export async function getSourceStatus() {
  try {
    const sources = [
      {
        name: 'CISA KEV',
        url: 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
        type: 'Government'
      },
      {
        name: 'NVD',
        url: 'https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=1',
        type: 'Government'
      },
      {
        name: 'GitHub Security',
        url: 'https://api.github.com/advisories?per_page=1',
        type: 'Community'
      },
      {
        name: 'EPSS',
        url: 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228',
        type: 'Research'
      }
    ];
    
    const statusChecks = await Promise.allSettled(
      sources.map(async (source) => {
        try {
          const startTime = Date.now();
          const response = await fetch(source.url, {
            method: 'HEAD',
            signal: AbortSignal.timeout(10000) // 10 second timeout
          });
          const responseTime = Date.now() - startTime;
          
          return {
            name: source.name,
            type: source.type,
            status: response.ok ? 'online' : 'error',
            responseTime,
            statusCode: response.status
          };
        } catch (error) {
          return {
            name: source.name,
            type: source.type,
            status: 'offline',
            responseTime: 0,
            error: error instanceof Error ? error.message : 'Unknown error'
          };
        }
      })
    );
    
    const results = statusChecks.map((check, index) => {
      if (check.status === 'fulfilled') {
        return check.value;
      } else {
        const source = sources[index] ?? { name: 'Unknown', type: 'Unknown' };
        return {
          name: source.name,
          type: source.type,
          status: 'failed',
          responseTime: 0,
          error: check.reason?.message || 'Status check failed'
        };
      }
    });
    
    return {
      success: true,
      sources: results,
      summary: {
        total: results.length,
        online: results.filter(r => r.status === 'online').length,
        offline: results.filter(r => r.status === 'offline').length,
        error: results.filter(r => r.status === 'error').length
      }
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Source status check failed'
    };
  }
}

export async function exportVulnerabilities(format: 'json' | 'csv' = 'json') {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const response = await fetch(`${baseUrl}/rss`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch RSS feed');
    }
    
    const content = await response.text();
    
    // Parse RSS to extract vulnerability data
    const items = content.match(/<item>[\s\S]*?<\/item>/g) || [];
    const vulnerabilities = items.map((item, index) => {
      const title = item.match(/<title><!\[CDATA\[(.*?)\]\]><\/title>/)?.[1] || '';
      const link = item.match(/<link>(.*?)<\/link>/)?.[1] || '';
      const pubDate = item.match(/<pubDate>(.*?)<\/pubDate>/)?.[1] || '';
      const categories = item.match(/<category>(.*?)<\/category>/g)?.map(cat => 
        cat.replace(/<\/?category>/g, '')
      ) || [];
      
      return {
        id: index + 1,
        title,
        link,
        publishedDate: pubDate,
        categories: categories.join(', ')
      };
    });
    
    if (format === 'csv') {
      const csvHeader = 'ID,Title,Link,Published Date,Categories\n';
      const csvRows = vulnerabilities.map(vuln => 
        `${vuln.id},"${vuln.title.replace(/"/g, '""')}","${vuln.link}","${vuln.publishedDate}","${vuln.categories}"`
      ).join('\n');
      
      return {
        success: true,
        data: csvHeader + csvRows,
        format: 'csv',
        count: vulnerabilities.length
      };
    }
    
    return {
      success: true,
      data: JSON.stringify(vulnerabilities, null, 2),
      format: 'json',
      count: vulnerabilities.length
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Export failed'
    };
  }
}